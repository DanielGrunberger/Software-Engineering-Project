package elements;

import primitives.Point3D;
import primitives.Ray;
import primitives.Util;
import primitives.Vector;

import java.util.ArrayList;
import java.util.List;

import static primitives.Util.isZero;

/**
 * The type Camera.
 *
 * @author David Zimberknopf & Daniel Grunberger
 */
public class Camera {
    private Point3D _p0;
    private Vector _vectorTowards;
    private Vector _vectorUp;
    private Vector _vectorRight;

    /******* CONSTRUCTORS *******/

    /**
     * Instantiates a new Camera.
     * The third vector, vectorRight is generated by the cross product
     * of the vectorTowards and vectorUp
     *
     * @param _p0            the camera location
     * @param _vectorTowards the vector towards the camera
     * @param _vectorUp      the vector up the camera
     * @throws IllegalArgumentException if vectors up and towards are not orthogonal
     */
    public Camera(Point3D _p0, Vector _vectorTowards, Vector _vectorUp) {

        if (!isZero(_vectorTowards.dotProduct(_vectorUp)))
            throw new IllegalArgumentException("Vectors Up and Towards are not orthogonal");

        this._p0 = new Point3D(_p0);
        this._vectorTowards = _vectorTowards.normalized();
        this._vectorUp = _vectorUp.normalized();
        this._vectorRight = this._vectorTowards.crossProduct(this._vectorUp);
    }

    /******* GETTERS  *******/

    /**
     * Gets point 0
     *
     * @return the p 0
     */
    public Point3D getP0() {
        return _p0;
    }

    /**
     * Gets vector towards.
     *
     * @return the vector towards
     */
    public Vector getVectorTowards() {
        return _vectorTowards;
    }

    /**
     * Gets vector up.
     *
     * @return the vector up
     */
    public Vector getVectorUp() {
        return _vectorUp;
    }


    /**
     * Gets vector right.
     *
     * @return the vector right
     */
    public Vector getVectorRight() {
        return _vectorRight;
    }

    /***** FUNCTIONS *******/

    /**
     * Constructs Ray through a single pixel of the screen
     *
     * @param nX             Number of pixels in X axis
     * @param nY             Number of pixels in Y axis
     * @param j              The current pixel in Y axis
     * @param i              The current pixel in X axis
     * @param screenDistance Distance from camera to screen
     * @param screenWidth    Screen width
     * @param screenHeight   Screen height
     * @return the generated ray
     * @throws IllegalArgumentException if distance to screen is zero
     */
    public Ray constructRayThroughPixel(int nX, int nY,
                                        int j, int i, double screenDistance,
                                        double screenWidth, double screenHeight) {

        double ry = screenHeight / nY;
        double rx = screenWidth / nX;

        double yi = ((i - nY / 2d) * ry + ry / 2d);
        double xj = ((j - nX / 2d) * rx + rx / 2d);

        Point3D pij = _p0.add(_vectorTowards.scale(screenDistance));

        if (!isZero(xj))
            pij = pij.add(_vectorRight.scale(xj));

        if (!isZero(yi))
            pij = pij.add(_vectorUp.scale(-yi));

        return new Ray(_p0, pij.subtract(_p0));

    }

    /**
     *
     * @param nX
     * @param nY
     * @param j
     * @param i
     * @param screenDistance the distance from screen
     * @param screenWidth the width of the screen
     * @param screenHeight the height of the screen
     * @param num_of_rays the number of rays
     * @return the list of rays
     */
    public List<Ray> constructRaysThroughPixel(int nX, int nY, int j, int i, double screenDistance,
                                               double screenWidth, double screenHeight, int num_of_rays)
    {
        if (isZero(screenDistance))
        {
            throw new IllegalArgumentException("distance cannot be 0");
        }
        List<Ray> sample_rays = new ArrayList<>();
        double Ry = screenHeight/nY;
        double Rx = screenWidth/nX;
        double yi =  ((i - nY/2d)*Ry);
        double xj=   ((j - nX/2d)*Rx);
        for (int row = 0; row < num_of_rays; ++row) {
            for (int column = 0; column < num_of_rays; ++column) {
                sample_rays.add(constructRaysThroughPixel(num_of_rays, num_of_rays,yi, xj, row, column,screenDistance, Rx, Ry));
            }
        }
        return sample_rays;
    }

    /**
     *
     * @param nX
     * @param nY
     * @param yi
     * @param xj
     * @param j
     * @param i
     * @param screenDistance  the distance from screen
     * @param pixelWidth the width of the screen
     * @param pixelHeight the height of the screen
     * @return the ray
     */
    private Ray constructRaysThroughPixel(int nX, int nY, double yi, double xj, int j, int i, double screenDistance,
                                          double pixelWidth, double pixelHeight)
    {
        Point3D Pc = new Point3D( _p0.add(_vectorTowards.scale(screenDistance)));
        double Ry = pixelHeight/nY;
        double Rx = pixelWidth/nX;
        double y_sample_i =  (i *Ry + Ry/2d);
        double x_sample_j=   (j *Rx + Rx/2d);
        Point3D Pij = Pc;
        if (!Util.isZero(x_sample_j + xj))
        {
            Pij = Pij.add(_vectorRight.scale(x_sample_j + xj));
        }
        if (!Util.isZero(y_sample_i + yi))
        {
            Pij = Pij.add(_vectorUp.scale(-y_sample_i -yi ));
        }
        Vector Vij = Pij.subtract(_p0);
        return new Ray(_p0,Vij);
    }
}
